name: Stage 2 — Staging Provision, Deploy, Test, Destroy

on:
  workflow_run:
    workflows: ["Stage 1 CI — Test, Build & Push to ACR (testing branch)"]
    types: [completed]
  workflow_dispatch:

env:
  LOCATION: eastasia
  ACR_LOGIN_SERVER: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  IMAGE_TAG: latest

jobs:
  staging:
    name: Provision, Deploy to Staging, Test, Destroy
    runs-on: ubuntu-latest

    # Run only when Stage 1 (workflow_run) succeeded AND source branch was 'testing'
    if: >
      ${{
        github.event_name == 'workflow_run' &&
        github.event.workflow_run.conclusion == 'success' &&
        github.event.workflow_run.head_branch == 'testing'
      }} || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (SPN)
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set run-scoped names
        id: names
        shell: bash
        run: |
          # Create unique resource names per run
          RG="week10-staging-${{ github.run_id }}"
          PLAN="week10-staging-plan-${{ github.run_id }}"
          PROD_APP="week10-staging-product-${{ github.run_id }}"
          ORDER_APP="week10-staging-order-${{ github.run_id }}"
          CUST_APP="week10-staging-customer-${{ github.run_id }}"
          echo "rg=$RG" >> $GITHUB_OUTPUT
          echo "plan=$PLAN" >> $GITHUB_OUTPUT
          echo "prod_app=$PROD_APP" >> $GITHUB_OUTPUT
          echo "order_app=$ORDER_APP" >> $GITHUB_OUTPUT
          echo "cust_app=$CUST_APP" >> $GITHUB_OUTPUT

      - name: Create Resource Group
        run: |
          az group create -n "${{ steps.names.outputs.rg }}" -l "${{ env.LOCATION }}"

      - name: Create App Service Plan (Linux, B1)
        run: |
          az appservice plan create \
            --name "${{ steps.names.outputs.plan }}" \
            --resource-group "${{ steps.names.outputs.rg }}" \
            --location "${{ env.LOCATION }}" \
            --is-linux \
            --sku B1

      - name: Derive ACR name and login (optional)
        id: acr
        shell: bash
        run: |
          ACR_NAME="${ACR_LOGIN_SERVER%%.*}"
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          # Login is optional for webapp deploy, but helpful for debugging
          az acr login --name "$ACR_NAME"

      # --- Create Web Apps (container) for staging ---
      - name: Create Product Staging WebApp
        run: |
          az webapp create \
            --resource-group "${{ steps.names.outputs.rg }}" \
            --plan "${{ steps.names.outputs.plan }}" \
            --name "${{ steps.names.outputs.prod_app }}" \
            --deployment-container-image-name "${{ env.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }}"

      - name: Create Order Staging WebApp
        run: |
          az webapp create \
            --resource-group "${{ steps.names.outputs.rg }}" \
            --plan "${{ steps.names.outputs.plan }}" \
            --name "${{ steps.names.outputs.order_app }}" \
            --deployment-container-image-name "${{ env.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }}"

      - name: Create Customer Staging WebApp
        run: |
          az webapp create \
            --resource-group "${{ steps.names.outputs.rg }}" \
            --plan "${{ steps.names.outputs.plan }}" \
            --name "${{ steps.names.outputs.cust_app }}" \
            --deployment-container-image-name "${{ env.ACR_LOGIN_SERVER }}/customer_service:${{ env.IMAGE_TAG }}"

      # If your ACR is private and Admin user is enabled, set registry credentials on each app:
      # You must create these two secrets in the repo: ACR_USERNAME and ACR_PASSWORD
      - name: Configure ACR credentials on WebApps
        if: ${{ secrets.ACR_USERNAME && secrets.ACR_PASSWORD }}
        run: |
          for APP in "${{ steps.names.outputs.prod_app }}" "${{ steps.names.outputs.order_app }}" "${{ steps.names.outputs.cust_app }}"; do
            az webapp config container set \
              --resource-group "${{ steps.names.outputs.rg }}" \
              --name "$APP" \
              --docker-custom-image-name "${{ env.ACR_LOGIN_SERVER }}/$(echo $APP | awk -F- '{print $3}')_service:${{ env.IMAGE_TAG }}" \
              --docker-registry-server-url "https://${{ env.ACR_LOGIN_SERVER }}" \
              --docker-registry-server-user "${{ secrets.ACR_USERNAME }}" \
              --docker-registry-server-password "${{ secrets.ACR_PASSWORD }}"
          done

      - name: Restart apps and warm up
        run: |
          for APP in "${{ steps.names.outputs.prod_app }}" "${{ steps.names.outputs.order_app }}" "${{ steps.names.outputs.cust_app }}"; do
            az webapp restart -g "${{ steps.names.outputs.rg }}" -n "$APP"
          done
          sleep 25

      # --- Simple acceptance/health checks ---
      - name: Health checks
        shell: bash
        run: |
          set -e
          for APP in "${{ steps.names.outputs.prod_app }}" "${{ steps.names.outputs.order_app }}" "${{ steps.names.outputs.cust_app }}"; do
            URL="https://${APP}.azurewebsites.net/health"
            echo "Checking $URL"
            # Retry a few times to allow container boot
            for i in {1..10}; do
              CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
              if [ "$CODE" = "200" ]; then
                echo "OK: $URL"
                break
              fi
              echo "Waiting for $URL (attempt $i/10, got $CODE)"
              sleep 6
            done
            # Final assert
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$CODE" != "200" ]; then
              echo "Health check failed for $URL (last code $CODE)"
              exit 1
            fi
          done

      # --- Always destroy staging environment ---
      - name: Destroy staging RG (always)
        if: always()
        run: |
          az group delete -n "${{ steps.names.outputs.rg }}" --yes --no-wait
